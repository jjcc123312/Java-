# Java虚拟机

## 1. JVM基本结构

<img src=".\img\1569379134930.png" alt="1569379134930" style="zoom:150%;" />

<img src=".\img\webp" alt="img" style="zoom:150%;" />

> 注意：java8开始已经取消了**方法区**，取而代之的是**元空间**

### 1.1 类加载子系统：

**类加载子系统负责从文件系统或者网络中加载`Class`信息**，加载的类信息**存放于一块称为方法区（java8开始为元空间）的内存空间**。除了类的信息外，方法区可能还会存放运行时常量池信息，包括~~字符串字面量~~和数字常量（这部分常量信息是Class文件常量池部分的内存映射）。

[java类加载器]: .\Java类加载器.md	"java类加载器"

### 1.2 ~~方法区~~（元空间）：

与java堆一样，是各个线程共享的区域，它用于存储已被类加载器加载的类信息：常量（**非字符串常量**），即时编译器编译后的代码等数据。**从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中。**

**在jdk1.8中，永久代** **已经不存在，存储的类信息、编译后的代码数据,运行时常量池等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。**

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过**元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，也不受GC的影响**

> **元空间里存储着class文件的信息和运行时常量池,class文件的信息包括类信息和class文件常量池，以及运行时常量池**；

![img](E:\软件开发资料\Java\Java资料\java高级\img\1212312451.png)

#### **1.2.1 三种情况：**

**Java1.8之前: **

![](.\img\20180821135022994.png)

**Java1.8之后: **

![](.\img\20180312125453153.jpg)

- **java7之前：**
  - 方法区即永久代位于java虚拟机内存中，方法区和java堆相互隔离，方法区里面存储了类加载器加载后的类信息：常量，静态变量，符号引用，即时编译器编译过后的代码等数据；
- **java7：**
  - jdk已经开始去永久代的规划；存储在方法区的部分数据已经转移到了java堆或者Native memory（本地内存）中；**字符串常量池和类的静态变量**转移存储到了java堆中；
- **java8：**
  - 取消永久代，取而代之的是元空间，**将方法区存放于元空间(Metaspace)，因而符号引用(Symbols)也转移存储到了Native memory中**，**元空间位于本地内存**，元空间仍然与java堆不相连，但与java堆共享物理内存，**当java heap空间不足时，会触发GC，但本地内存不足不会触发GC **
- **永久代向元空间转化的理由：**

  - 字符串存在永久代中，**容易出现性能问题和内存溢出。**
  - 将字符串常量池从PermGen分离出来，与**类元数据（描述数据的数据，譬如XML文件中的<title>标签）分开，提升类元数据的独立性**
  - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
  - 在PermGen中元数据可能会随着每一次Full GC发生而进行移动。**HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理PermGen中的元数据，分离出来以后可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化**。
  - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

### 1.3 Java堆

**java堆在虚拟机启动的时候建立**，它是java程序最主要的内存工作区域。**几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的**，这是一块与java应用密切相关的内存空间。

**特点：**

1. 堆用于存储创建好的对象和数组
2. jvm只有一个堆，被所有线程共享
3. 堆是一个不连续性的内存空间，分配灵活，速度慢

**java堆内存分为`年轻代（Young Generation）`和`年老代（old Generation）`**。年轻代又分为两种：`Eden`区域，两个大小相等的`Survivor`区域。

所有新建的Object都会存放在`Young Generation`中。如果Young Generation的数据在一次或多次GC后存活下来，将会转移到Old Generation中。新的对象总是创建在Eden Generation；

堆空间内存分配（默认情况下）
老年代 ： 三分之二的堆空间
年轻代 ： 三分之一的堆空间 
eden区： 8/10 的年轻代空间
survivor0 : 1/10 的年轻代空间
survivor1 : 1/10 的年轻代空间
命令行上执行如下命令，查看所有默认的jvm参数
`java -XX:+PrintFlagsFinal -version`

`-XX:InitialSurvivorRatio`    新生代Eden/Survivor空间的初始比例
`-XX:Newratio    Old`区 和 `Yong`区 的内存比例

<img src=".\img\345531-20151115204320728-1210139023-1551797567453.png" alt="img" style="zoom:150%;" />

<img src=".\img\70" alt="heap" style="zoom:150%;" />

#### 年轻代：

所有新生成的对象首先都会存放在`Eden Generation`中，**年轻代的目标就是尽可能的快速收集掉那些声明周期短的对象。**年轻代分三个去，一个Eden区，两个大小相等的Survivor区（一般而言，可以配置多个）。大部分对象在Eden区中生成。

#### 年老代：

**在年轻代中经理了N次（默认15次）垃圾回收后仍然存活的对象，就会被放到年老代中。**因此，可以认为年老代中存放的都是一些生命周期较长的对象。

### 1.4 直接内存

java 的 NIO 库允许 java 程序使用直接内存。直接内存是在 java 堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于 java 堆。因此**出于性能的考虑，读写频繁的场合可能会考虑使用直接内存**。由于**直接内存在 java 堆外，因此它的大小不会直接受限于 Xmx 指定的最大堆大小**，但是系统内存是有限的，java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。

### 1.5 垃圾回收系统

垃圾回收系统是 java 虚拟机的重要组成部分，**垃圾回收器可以对~~方法区~~、java 堆和直接内存进行回收。其中，java 堆是垃圾收集器的工作重点**。和 C/C++不同，java 中所有的对象空间释放都是隐式的，也就是说，java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。

### 1.6 Java栈

**每一个 java 虚拟机线程都有一个私有的 java 栈，一个线程的 java 栈在线程创建的时候被创建**，java 栈中保存着帧信息，java 栈中保存着局部变量、方法参数，同时和 java 方法的调用、返回密切相关。

1. 栈描述的是方法执行的内存模型，**每个方法被调用都会创建一个栈帧**（局部变量表，操作数栈，指向运行时常量池的引用，方法返回地址等）
2. **JVM为每一个线程创建一个栈**，用于存放该线程执行方法的信息
3. **栈属于线程私有，不能实现线程间的共享**
4. 栈的储存特性是**先进后出，后进先出**；
5. 栈是由系统自动分配, 速度快!栈是一个连续的内存空间

#### 局部变量表

**用于存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）**。对于**基本数据类型的变量，直接存储他的值，对于引用类型的变量，则存的是指向对象的引用**。局部变量表的大小在编译器就可以确定其大小，因此**在程序执行期间局部变量表的大小是不会改变的**。

#### 操作数栈

**栈最典型的一个应用就是用来对表达式求值**。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，**程序中的所有计算过程都是在借助于操作数栈来完成的。**

#### 指向运行时常量池的引用

**在方法执行的过程中有可能用到类中的常量，所以必须要有一个引用指向运行时常量池。**

#### 方法返回地址

**当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。**

###  1.7 本地方法栈

本地方法栈和 java 栈非常类似，最大的不同在于 **java 栈用于方法的调用，而本地方法栈则用于本地方法的调用**，作为对 java 虚拟机的重要扩展，java 虚拟机允许 java 直接调用本地方法（通常使用 C 编写）

### 1.8  PC  寄存器

也叫**程序计数器**，**寄存器是每个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器**。倘**若当前执行的是JVM方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器为空。**

- 程序计数器是指CPU中的寄存器，**保存的是程序当前执行的指令的地址**（也可以说保存下一条指令的所在存储单元的地址）
- 在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，所以PC寄存器是每个线程所私有的；
- 唯一一个在Java虚拟机规范中没有任何**OutOfMemoryError**的区域；

### 1.9 执行引擎

执行引擎是Java虚拟机的最核心组件之一，它负责**执行虚拟机中的字节码，或者执行本地方法**，现代虚拟机为了提高执行效率，会使用即时编译(just in time)技术**将方法编译成机器码后再执行**。



## 2. 常量池

用final修饰的变量表示常量，值一旦给定，无法改变；

修饰方法：该类不可被子类重写，可以被重载；

修饰类：无法被继承；

final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。

java的常量池分为三种：

- Class常量池
- 运行时常量池
- String常量池

### 2.1 Class常量池

所处区域：class文件中

诞生时间：编译时

内容概要：符号引用( 符号引用包括：1.类的全限定名，2.字段名和描述，3.方法名和描述。)和字面量 （字符串，使用final修饰的基本数据类型，基本数据类型的值）

<img src=".\img\20141010133603275.png" alt="img" style="zoom:150%;" />

<img src=".\img\14141412213.png" alt="这里写图片描述" style="zoom:150%;" />

**class常量池是在编译的时候每个class都有的，在编译阶段，存放的是符号引用和常量**。class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，**用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)**。 字面量就是我们所说的常量概念，**如文本字符串、被声明为final的常量值等**。 **符号引用是一组符号来描述所引用的目标**，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，**直接引用一般是指向元空间的本地指针**，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

### 2.2 运行时常量池

所处区域：元空间

诞生时间：类加载器加载Class信息进入元空间时

**jvm在执行某个类的时候，必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中**，由此可知，**运行时常量池也是每个类都有一个**。class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，**解析的过程会去查询全局字符串池**，也就是我们所说的StringTable，以**保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的**。

运行时常量池是当class文件被加载完成后，**java虚拟机会将class文件常量池里的内容转移到运行时常量池里，在class文件常量池的符号引用有一部分是会被转变为直接引用的**，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。

**运行时常量池里的内容除了是class文件常量池里的内容外，还将class文件常量池里的符号引用转变为直接引用，而且运行时常量池里的内容是能动态添加的**。例如调用String的intern方法就能将string的值添加到String常量池中。

### 2.3 字符串常量池

所处区域：java堆

诞生时间：**类加载完成，经过验证，准备后（类的初始化阶段）在堆中生成字符串对象实例，然后将引用存入string pool**

全局常量池里的类容是在**类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用存入string pool中**（**字符串常量池存的是引实例对象的引用，而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**）；在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个**StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。**

其实，“使用常量池”对应的字节码是一个 ldc 指令，**在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（**jdk1.7)。**String 类的 intern() 方法还可在运行期间把字符串放到字符串常量池中。**

8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池

### 总结：

- 字符串全局常量池在每个JVM中只有一份，存放的是字符串实例对象的引用
- class常量池是在class文件编译的时候就有的，在编译阶段存放的是符号引用和常量
- 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用和常量转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，**类在解析之后，将符号引用替换成直接引用**，对于字符串与全局常量池中的引用值保持一致。



## 3. JVM优化

























